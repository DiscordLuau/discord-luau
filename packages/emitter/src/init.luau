--[[
	An emitter that can be used to emit events, this class will be used to push updates from the Discord Websockets
		out to the Consumers of this library.

	This library has Unit Tests written for it under the /tests directory.
]]

local Emitter = {}

Emitter.Interface = {}
Emitter.Prototype = {}

--[[
	Listen to this event, returns a function that can be called to disconnect the listener
]]
function Emitter.Prototype.listen<T...>(self: Emitter<T...>, callback: (T...) -> ()): () -> ()
	local thread = coroutine.create(function()
		while true do
			callback(coroutine.yield())
		end
	end)

	local status, response = coroutine.resume(thread)

	if not status then
		warn(response)
		print(debug.traceback(thread))
	end

	table.insert(self._connectedThreads, thread)

	return function()
		local index = table.find(self._connectedThreads, thread)

		if index then
			table.remove(self._connectedThreads, index)
		end
	end
end

--[[
	Listen to this event once, this will automatically disconnect after the first invocation
]]
function Emitter.Prototype.listenOnce<T...>(self: Emitter<T...>, callback: (T...) -> ()): () -> ()
	local disconnect

	disconnect = self:listen(function(...)
		disconnect()

		callback(...)
	end)

	return disconnect
end

--[[
	Wait for this event to be emitted from, returns the result of the emittion
]]
function Emitter.Prototype.wait<T...>(self: Emitter<T...>): T...
	table.insert(self._yieldingThreads, coroutine.running())

	return coroutine.yield()
end

--[[
	Responsible for invoking all the threads that are listening to this emitter.

	This will additionally resume all the threads that are currently waiting for an event to be emitted.
]]
function Emitter.Prototype.invoke<T...>(self: Emitter<T...>, ...): ()
	for _, thread in self._yieldingThreads do
		coroutine.resume(thread, ...)
	end

	self._yieldingThreads = {}

	for _, thread in self._connectedThreads do
		coroutine.resume(thread, ...)
	end
end

--[[
	Constructor for the Emitter object, will return a new instance of the Emitter object.
]]
function Emitter.Interface.new<T...>(): Emitter<T...>
	return setmetatable(
		{
			_yieldingThreads = {},
			_connectedThreads = {},
		} :: Emitter<T...>,
		{
			__index = Emitter.Prototype,
		}
	)
end

export type Emitter<T...> = typeof(Emitter.Prototype) & {
	_yieldingThreads: { thread },
	_connectedThreads: { thread },
}

return Emitter.Interface
